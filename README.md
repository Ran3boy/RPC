# Глоссарий терминов ВКР  
## RPC / gRPC / Protocol Buffers / Docker

Проект представляет собой микросервисное приложение — глоссарий терминов,
используемых в выпускной квалификационной работе на тему:

**«Сравнительный анализ технологии Web Components и современных
фронтенд-фреймворков для разработки пользовательских интерфейсов»**

Практическая работа выполнена в рамках изучения технологий  
**RPC, gRPC и Protocol Buffers**.

> Ссылка на GitHub-репозиторий: https://github.com/Ran3boy/RPC **

---

## 1. Цель практической работы

Целью практической работы является:

- изучение принципов удалённого вызова процедур (RPC);
- реализация взаимодействия сервисов с использованием **gRPC**;
- описание контрактов API с помощью **Protocol Buffers**;
- контейнеризация микросервисов с использованием **Docker** и **Docker Compose**;
- демонстрация процесса развёртывания и проверки работы сервиса
  с оформлением отчёта в формате Markdown.

---

## 2. Используемые технологии

В ходе выполнения работы были использованы следующие технологии:

- **gRPC** — фреймворк для удалённого вызова процедур поверх HTTP/2;
- **Protocol Buffers** — бинарный формат сериализации данных и описание API;
- **Python** — язык реализации сервисов;
- **Docker** — контейнеризация приложений;
- **Docker Compose** — оркестрация микросервисов;
- **FastAPI** — web-шлюз для доступа к сервису через браузер.

---

## 3. Архитектура приложения

Приложение реализовано в виде микросервисной архитектуры
и состоит из двух основных сервисов.

### 3.1 gRPC-сервис глоссария (backend)

- реализует бизнес-логику хранения и получения терминов;
- использует Protocol Buffers для описания сообщений;
- взаимодействует с клиентами по протоколу gRPC;
- работает на порту `50051`.

### 3.2 Web-шлюз (frontend gateway)

- предоставляет web-интерфейс и HTTP API;
- взаимодействует с backend-сервисом исключительно через gRPC;
- предназначен для демонстрации работы сервиса;
- работает на порту `8000`.

---

## 4. Структура проекта

```text
vkr-glossary-grpc/
 ├─ glossary_service/      # gRPC backend-сервис
 ├─ web_gateway/           # Web UI и HTTP API
 ├─ protobufs/             # .proto файлы (контракты)
 ├─ screenshots/           # Скриншоты работы сервиса
 ├─ docker-compose.yml     # Конфигурация Docker Compose
 └─ README.md              # Отчёт по практической работе
```

---

В данном разделе приведён пошаговый процесс развёртывания проекта
и проверки его работоспособности.

### 5.1 Предварительные требования

Для запуска проекта необходимо:

- установленный и запущенный **Docker Desktop**;
- (рекомендуется) установленный **Git** для публикации проекта в GitHub.

Проверка корректности установки Docker выполняется следующими командами:

```bash
docker --version
docker compose version
```

### 5.2 Сборка и запуск проекта

В корневой директории проекта необходимо выполнить команду:

```bash
docker compose up --build
```

В процессе выполнения команды:

- происходит сборка Docker-образов сервисов;
- запускаются два контейнера: gRPC backend и web-шлюз.

Для остановки работы сервисов используется сочетание клавиш **Ctrl + C**,
после чего рекомендуется выполнить команду:

```bash
docker compose down
```

### 5.3 Проверка запуска контейнеров

После запуска проекта необходимо убедиться,
что контейнеры успешно запущены.

Для этого выполняется команда:

```bash
docker ps
```

#### Ожидаемый результат

В списке запущенных контейнеров должны присутствовать два сервиса:
- контейнер web-шлюза (порт **8000**);
- контейнер gRPC-сервиса глоссария (порт **50051**).

Названия контейнеров могут незначительно отличаться
в зависимости от конфигурации Docker Compose.

---

### 5.4 Проверка работы web-интерфейса

После успешного запуска контейнеров необходимо открыть
в браузере следующий адрес:

**http://localhost:8000**

Если отображается веб-страница глоссария, это означает, что:
- web-шлюз функционирует корректно;
- взаимодействие между web-сервисом и backend-сервисом
осуществляется через протокол gRPC.

#### Скриншот работающего сервиса

Web-интерфейс доступен по адресу:  
**http://localhost:8000**

![Глоссарий ВКР](screenshots/web-ui.png)

---

### 5.5 Проверка работы HTTP API (дополнительно)

Для дополнительной проверки работоспособности системы
можно обратиться к HTTP API web-шлюза.

Для этого необходимо открыть в браузере:

**http://localhost:8000/api/terms**

Ожидается получение JSON-ответа, что подтверждает
корректную работу web-сервиса и его взаимодействие
с gRPC backend-сервисом.

---

## 6. Результаты выполнения практической работы

В ходе выполнения практической работы были получены следующие результаты:

- реализовано микросервисное приложение на основе RPC-подхода;
- организовано взаимодействие сервисов с использованием gRPC;
- применён Protocol Buffers для описания контрактов API;
- выполнена контейнеризация сервисов с помощью Docker.


# Сравнение производительности REST, gRPC и GraphQL: подборка исследований

## Исследовательская задача
Сравнение REST, RPC (gRPC) и GraphQL по производительности, латентности и потреблению ресурсов на основе экспериментальных работ с замерами.

---

## 1. REST vs GraphQL

### Vadlamani et al. (SERIP 2021)
**Сравнение GitHub REST API vs GitHub GraphQL API**
- **Методология**: парные эквивалентные запросы, 50 повторов на запрос, статистический анализ (t-тесты).
- **Ключевой результат**: нет абсолютного победителя. 
  - Query1: REST ≈ 171 мс vs GraphQL ≈ 177 мс (разница незначительна)
  - Query3: REST ≈ 225 мс vs GraphQL ≈ 145 мс (GraphQL быстрее)
  - Query4: REST ≈ 338 мс vs GraphQL ≈ 388 мс (REST быстрее)

### Jin et al. (University of Washington)
**GraphQL vs REST для serverless data persistence**
- **Стек**: AWS AppSync/Apollo Server (GraphQL) vs API Gateway + Lambda (REST), PostgreSQL (Aurora).
- **Метрики**: RTT (round-trip time), throughput при разной конкуренции и сетевых условиях.
- **Ключевой результат**:
  - Apollo Server показывал на **25–67% меньшее среднее RTT** vs REST для большинства операций.
  - При очень высокой конкурентной нагрузке **масштабируемость GraphQL была хуже**, чем у REST.

---

## 2. REST vs GraphQL vs gRPC (комплексное сравнение)

### Niswar et al. (2024)
**REST vs GraphQL vs gRPC в микросервисной архитектуре**
- **Эксперимент**: микросервисы в контейнерах + БД (Redis/MySQL), два сценария (flat vs nested data), 100–500 запросов.
- **Метрики**: время ответа (response time), загрузка CPU.
- **Ключевой результат** (по возрастанию latency):
  1. **gRPC** — самый быстрый
  2. **REST**
  3. **GraphQL** — самый медленный
  - **GraphQL показал наибольшую загрузку CPU** по сравнению с REST и gRPC.

---

## 3. REST vs gRPC (RPC)

### Bolanowski et al. (SOMET 2022)
**“Efficiency of REST and gRPC…” на .NET**
- **Подход**: анализ различных классов коммуникационных задач.
- **Ценность**: работа определяет **типы сценариев, где эффективнее REST или gRPC** (по времени ответа и условиям), а не просто констатация «что быстрее».

### gRPC Mobile Benchmarks (grpc.io, 2016)
**Официальные бенчмарки gRPC/Protobuf vs HTTP/JSON для мобильных платформ**
- **Сравнение**:
  - Protobuf vs JSON (сериализация/десериализация, размер сообщений)
  - gRPC unary vs RESTful HTTP JSON (end-to-end latency, размер пакетов)
- **Статус**: канонический источник для оценки преимуществ Protobuf/gRPC, особенно в мобильном контексте.

---

## Выводы

| Технология | Сильные стороны | Слабые стороны | Идеальный сценарий |
|------------|----------------|----------------|---------------------|
| **GraphQL** | Устраняет over/under-fetching, гибкость запросов | Выше latency на части запросов, хуже масштабируемость при экстремальной конкуренции, высокая нагрузка на CPU | Сложные данные с переменной структурой, клиенты с ограниченным каналом |
| **gRPC** | Низкая латентность, бинарная сериализация (Protobuf), HTTP/2 | Ограниченная поддержка в браузере, строгий контракт | Внутренние микросервисы, потоковая передача, чувствительные к задержкам системы |
| **REST** | Универсальность, кэширование, поддержка браузеров | Over/under-fetching, множественные запросы для сложных данных | Публичные API, веб-приложения, экосистемы с разнородными клиентами |

**Общий вывод**: Универсального победителя нет. Выбор зависит от:
- **Типа данных** (flat / nested)
- **Размера полезной нагрузки**
- **Уровня конкурентности**
- **Требований к контракту и совместимости с браузером**
